### Starting build.
# Target: dinosaur.ml.depends, tags: { extension:ml, file:dinosaur.ml, ocaml, ocamldep, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamldep.opt -modules dinosaur.ml > dinosaur.ml.depends # cached
# Target: ast.ml.depends, tags: { extension:ml, file:ast.ml, ocaml, ocamldep, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamldep.opt -modules ast.ml > ast.ml.depends # cached
# Target: ast.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:ast.cmo, file:ast.ml, implem, ocaml, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamlc.opt -c -I /Users/daisyye/.opam/4.13.1/lib/llvm -o ast.cmo ast.ml # cached
# Target: irgen.ml.depends, tags: { extension:ml, file:irgen.ml, ocaml, ocamldep, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamldep.opt -modules irgen.ml > irgen.ml.depends
# Target: sast.ml.depends, tags: { extension:ml, file:sast.ml, ocaml, ocamldep, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamldep.opt -modules sast.ml > sast.ml.depends # cached
# Target: sast.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:sast.cmo, file:sast.ml, implem, ocaml, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamlc.opt -c -I /Users/daisyye/.opam/4.13.1/lib/llvm -o sast.cmo sast.ml # cached
# Target: parser.mly, tags: { extension:mly, file:parser.mly, infer, ocaml, ocamlyacc, parser, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamlyacc parser.mly # cached
# Target: parser.mli.depends, tags: { extension:mli, file:parser.mli, ocaml, ocamldep, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamldep.opt -modules parser.mli > parser.mli.depends # cached
# Target: parser.cmi, tags: { byte, compile, extension:mli, file:parser.mli, interf, ocaml, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamlc.opt -c -I /Users/daisyye/.opam/4.13.1/lib/llvm -o parser.cmi parser.mli # cached
# Target: scanner.mll, tags: { extension:mll, file:scanner.mll, lexer, ocaml, ocamllex, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamllex.opt -q scanner.mll # cached
# Target: scanner.ml.depends, tags: { extension:ml, file:scanner.ml, ocaml, ocamldep, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamldep.opt -modules scanner.ml > scanner.ml.depends # cached
# Target: semant.ml.depends, tags: { extension:ml, file:semant.ml, ocaml, ocamldep, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamldep.opt -modules semant.ml > semant.ml.depends # cached
# Target: irgen.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:irgen.cmo, file:irgen.ml, implem, ocaml, quiet }
/Users/daisyye/.opam/4.13.1/bin/ocamlc.opt -c -I /Users/daisyye/.opam/4.13.1/lib/llvm -o irgen.cmo irgen.ml
+ /Users/daisyye/.opam/4.13.1/bin/ocamlc.opt -c -I /Users/daisyye/.opam/4.13.1/lib/llvm -o irgen.cmo irgen.ml
File "irgen.ml", lines 39-45, characters 21-23:
39 | .....................function
40 |       A.Int   -> i32_t
41 |     | A.Float -> float_t
42 |     | A.Bool  -> i1_t
43 |     | A.Char -> i1_t
44 |     | A.None -> void_t
45 |     | A.String -> str_t
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
List (_, _)
File "irgen.ml", lines 52-54, characters 17-53:
52 | .................match t with
53 |         A.Int -> L.const_int (ltype_of_typ t) 0
54 |       | A.Float -> L.const_float (ltype_of_typ t) 0.0
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Bool|Char|None|String|List (_, _))
File "irgen.ml", lines 110-144, characters 50-63:
110 | ..................................................match e with
111 |         SInt_Literal(i)  -> L.const_int i32_t i
112 |       | SFloat_Literal(f) -> L.const_float_of_string float_t f
113 |       | SChar_Literal(c) -> L.const_int i8_t (Char.code c)
114 |       | SString_Literal(str)-> L.build_global_stringptr str "STRINGLITERAL" builder
...
141 |         let (fdef, fdecl) = StringMap.find f function_decls in
142 |         let llargs = List.rev (List.map (build_expr builder) (List.rev args)) in
143 |         let result = f ^ "_result" in
144 |         L.build_call fdef (Array.of_list llargs) result builder
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SListLit _|SListAssign (_, _)|SAccess (_, _)|SSlice (_, _, _))
File "irgen.ml", line 187, characters 23-33:
187 |         let bool_val = build_expr builder fst(if_r.sif_branch) in
                             ^^^^^^^^^^
Error: This function has type L.llbuilder -> Sast.sexpr -> L.llvalue
       It is applied to too many arguments; maybe you forgot a `;'.
Command exited with code 2.
# Compilation unsuccessful.
